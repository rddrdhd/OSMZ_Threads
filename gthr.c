#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <string.h>

#include "gthr.h"
#include "gthr_struct.h"

static int LOWEST_PRIORITY = 10; // for PRI mode
static int HIGHEST_PRIORITY = 0; // for PRI mode
static int HIGHEST_TICKET = 100; // for LS mode

// function triggered periodically by timer (SIGALRM)
void gthandle(int sig) {
    gtyield();
}

int get_random_num(int lower, int upper) {
    return (rand() % (upper - lower + 1)) + lower;
}

// initialize first thread as current context
void gtinit(char mode[]) {
    struct timeval current_time;
    gettimeofday(&current_time, NULL);
    gtcur = &gttbl[0];			// initialize current thread with thread #0
    gtcur->st = Running;		// set current to running

    gtcur->wait_time.sum = 0;
    gtcur->wait_time.min = 0;
    gtcur->wait_time.max = 0;
    gtcur->wait_time.count = 0;
    gtcur->run_time.sum = 0;
    gtcur->run_time.min = 0;
    gtcur->run_time.max = 0;
    gtcur->run_time.count = 0;
    gtcur->t_stop = current_time;
    gtcur->t_start = current_time;
    gtcur->lottery_bound = 0;

    // set mode from main() args
    if (strcmp(mode, "PRI") == 0)
        gtcur->mode = PRI;
    else if (strcmp(mode, "LS") == 0)
        gtcur->mode = LS;
    else if (strcmp(mode, "RR") == 0)
        gtcur->mode = RR;
    else
        gtcur->mode = UNDEFINED;

    signal(SIGALRM, gthandle);	// register SIGALRM, signal from timer generated by alarm
}

// exit thread
void __attribute__((noreturn)) gtret(int ret) {
    if (gtcur != &gttbl[0]) {	// if not an initial thread,
        gtcur->st = Unused;		// set current thread as unused
        gtyield();				// yield and make possible to switch to another thread
        assert(!"reachable");	// this code should never be reachable ... (if yes, returning function on stack was corrupted)
    }
    while (gtyield());			// if initial thread, wait for other to terminate
    exit(ret);
}

// func for LS mode
void recalculate_tickets(int process_count, int priority_weights_sum) {
    struct gt* t = &gttbl[0];
    int priority_weight, last_bound, weight;
    t->lottery_bound = 0;

    while (t != &gttbl[process_count]) { // iterating only used slots
        last_bound = t->lottery_bound;
        t++;


        priority_weight = ((LOWEST_PRIORITY + 1)) - t->priority;
        weight = (int)(((float)priority_weight / (float)priority_weights_sum) * (float)HIGHEST_TICKET);
        t->lottery_bound = last_bound + weight;
        //printf("\tbound:\t%d,\tweight:\t%d\n", t->lottery_bound, weight);
    }
}

// switch from one thread to other
bool gtyield(void) {

    struct gt* p;
    struct gtctx* old, * new;

    resetsig(SIGALRM);			// reset signal

    p = gtcur;
    bool found = false;
    int winning_ticket;

    switch(gttbl[0].mode){      // mode set only in main thread

        // Round Robin mode
        case RR:
            while (!found) {			    // iterate through gttbl[] until we find new thread in state Ready 
                if (++p == &gttbl[MaxGThreads])	    // at the end rotate to the beginning
                    p = &gttbl[0];
                if (p->st == Ready)
                    found = true;
                if (p == gtcur)						// did not find any other Ready threads
                    return false;
            }
            break;

        // Round Robin with priorities mode
        case PRI:
            for (int i = HIGHEST_PRIORITY; ((i <= LOWEST_PRIORITY) && !found); i++) {  // 0 = highest priority, 10 = lowest
                while (!found) {
                    if (++p == &gttbl[MaxGThreads]) {	                // at the end rotate to the beginning
                        p = &gttbl[0];
                    }

                    if (p->st == Ready) {
                        if ((p->priority - p->starvingCount) <= i) {    // ready thread with highest priority found, break both loops
                            found = true;
                            p->starvingCount = 0;                       // reset starving count after thread is found
                            break;
                        } else {
                            p->starvingCount++;
                        }
                    }

                    if (p == gtcur) {                                   // did not find any Ready threads with i priority
                        break;
                    }
                }
            }

            if (p == gtcur) {
                return false; // did not find any other Ready threads
            }
            break; 

        // Loterry scheduling mode
        case LS:
            p = &gttbl[0];
            winning_ticket = get_random_num(0, HIGHEST_TICKET);
            
            while (!found) {
                int last_bound = p->lottery_bound;
                if (++p == &gttbl[MaxGThreads])	    
                    return false;

                if (winning_ticket <= p->lottery_bound){ // i found the process with winning ticket
                    //TODO: Nechce mi to opakovane spoustet ty thready, proste hleda dal
                   // printf("%02d < %02d < %02d", last_bound, winning_ticket, p->lottery_bound);
                    if (p->st == Ready) {
                     //   printf("\tpriorty %d ready!\n",p->priority);
                        found = true;
                        break;
                    }

                   if (!found) {
                        winning_ticket = get_random_num(0, HIGHEST_TICKET); // give it another try - can be rounding mistake (floor of bounds) too
                     //   printf("\tpriorty %d NOT ready!\n", p->priority);
                    }
                }
            }

            break;

        default:
            printf(" Use one of those args: \n\t'RR' for round robin,\n\t'PRI' for prioritized round robin,\n\t'LS' for lottery scheduling\n\n");
            return 0;
            break;
    }


    struct timeval current_time;
    gettimeofday(&current_time, NULL);

    if (gtcur->st != Unused) {			// switch current to Ready and new thread found in previous loop to Running
        gtcur->st = Ready;
        if (gtcur->t_start.tv_usec+gtcur->t_start.tv_sec > 0) {
            long diff = time_diff(current_time, gtcur->t_start);
            gtcur->run_time.sum += diff;
            if (gtcur->run_time.min == 0)
                gtcur->run_time.min = diff;
            if (gtcur->run_time.min > diff)
                gtcur->run_time.min = diff;
            if (gtcur->run_time.max < diff)
                gtcur->run_time.max = diff;
        }
        gtcur->t_stop = current_time;
        gtcur->run_time.count++;
    }

    p->st = Running;
    if (p->t_start.tv_usec + p->t_start.tv_sec > 0) {
        long diff = time_diff(current_time, p->t_stop);
        p->wait_time.sum += diff;
        if (p->wait_time.min == 0) 
            p->wait_time.min = diff;
        if (p->wait_time.min > diff) 
            p->wait_time.min = diff;
        if (p->wait_time.max < diff) 
            p->wait_time.max = diff;
    }

    p->t_start = current_time;
    p->wait_time.count++;

    old = & gtcur->ctx;		            // prepare pointers to context of current (will become old) 
    new = & p->ctx;						// and new to new thread found in previous loop
    gtcur = p;							// switch current indicator to new thread
    gtswtch(old, new);					// perform context switch (assembly in gtswtch.S)
 
    return true;
}

// return function for terminating thread
void gtstop(void) {
  gtret(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gtgo(void( * f)(void), int priority) {
  char * stack;
  struct gt * p;

  for (p = & gttbl[0];; p++)			// find an empty slot
    if (p == & gttbl[MaxGThreads])		// if we have reached the end, gttbl is full and we cannot create a new thread
      return -1;
    else if (p->st == Unused)
    break;								// new slot was found

  stack = malloc(StackSize);			// allocate memory for stack of newly created thread
  if (!stack)
    return -1;

  *(uint64_t * ) & stack[StackSize - 8] = (uint64_t) gtstop;	//	put into the stack returning function gtstop in case function calls return
  *(uint64_t * ) & stack[StackSize - 16] = (uint64_t) f;		//  put provided function as a main "run" function
  p->ctx.rsp = (uint64_t) & stack[StackSize - 16];			    //  set stack pointer
  
  p->st = Ready;	                                            //  set state
  if (gttbl[0].mode == PRI || gttbl[0].mode == LS) {
    if (priority >= HIGHEST_PRIORITY && priority <= LOWEST_PRIORITY)
        p->priority = priority;
    else
        p->priority = LOWEST_PRIORITY;
  }
 
  if (gttbl[0].mode == LS) {
      int process_count = 0;
      int priority_weights_sum = 0;
      struct gt* c;

      // count used slots in table
      for (c = &gttbl[1];; c++) { //
          if (c->st != Unused) {
              priority_weights_sum += ((LOWEST_PRIORITY+1) - c->priority);
              process_count++;
          }
          else {
              break;
          }
      }
     // printf("### processes count: %d, priority weights sum: %d ################\n", process_count, priority_weights_sum);

      recalculate_tickets(process_count, priority_weights_sum);

      //p->lottery_bound = ((LOWEST_PRIORITY+1) - p->priority)*10;
      //printf("New Lottery bound: %d", p->lottery_bound);
  }

  p->wait_time.sum = 0;
  p->wait_time.min = 0;
  p->wait_time.max = 0;
  p->wait_time.count = 0;
  p->run_time.sum = 0;
  p->run_time.min = 0;
  p->run_time.max = 0;
  p->run_time.count = 0;
  p->starvingCount = 0;

  struct timeval current_time;
  gettimeofday(&current_time, NULL);
  p->t_stop = current_time;
  p->t_start = current_time;

  return 0;
}

void resetsig(int sig) {
  if (sig == SIGALRM) {
    alarm(0);			// Clear pending alarms if any
  }

  sigset_t set;				// Create signal set
  sigemptyset( & set);		// Clear it
  sigaddset( & set, sig);	// Set signal (we use SIGALRM)

  sigprocmask(SIG_UNBLOCK, & set, NULL);	// Fetch and change the signal mask

  if (sig == SIGALRM) {
    // Generate alarms
    ualarm(500, 500);		// Schedule signal after given number of microseconds
  }
}

int uninterruptibleNanoSleep(time_t sec, long nanosec) {
  struct timespec req;
  req.tv_sec = sec;
  req.tv_nsec = nanosec;

  do {
    if (0 != nanosleep( & req, & req)) {
      if (errno != EINTR)
        return -1;
    } else {
      break;
    }
  } while (req.tv_sec > 0 || req.tv_nsec > 0);
  return 0; /* Return success */
}

// output stuff
void handle_sigint(int sig) {
    char *mode_label;
    int mode_value;
    if (gttbl[0].mode == LS) {
        mode_label = " TIX ";
    }
    else {
        mode_label = "PRIOR";
    }
    struct gt* p;
    printf("\n\n|      THREAD    |\t\tRUN TIME (ms)\t\t|\t\tWAIT TIME (ms)\t\t|\n");
    printf("|----------------|--------------------------------------|---------------------------------------|\n");
    printf("|   ID\t | %s |      SUM\t|  AVG\t|  MIN\t|  MAX\t|      SUM\t|  AVG\t|  MIN\t|  MAX\t|\n", mode_label);
    printf("|--------|-------|--------------|-------|-------|-------|---------------|-------|-------|-------|\n");
    for (int i = 1; i < MaxGThreads; i++) {
        p = &gttbl[i];
        if (i > 0) {
            if (gttbl[0].mode == LS) {

                int last_bound = gttbl[i - 1].lottery_bound;
                mode_value = p->lottery_bound - last_bound; // how much tickets does it have

            }
            else {
                mode_value = p->priority;
            }
        }
        else {
            mode_value = p->lottery_bound; // how much tickets does it have

        }
        
        
        printf("| %d\t | %d\t | %06.3f\t| %0.3f\t| %0.3f\t| %0.3f\t| %06.3f\t| %0.3f\t| %0.3f\t| %0.3f |\n",
            i, 
            mode_value,
            (float)p->run_time.sum/1000,
            (float)(p->run_time.sum/p->run_time.count)/1000,
            (float)p->run_time.min/1000,
            (float)p->run_time.max/1000,
            (float)p->wait_time.sum/1000,
            (float)(p->wait_time.sum/p->wait_time.count)/1000,
            (float)p->wait_time.min/1000,
            (float)p->wait_time.max/1000 ); // everything is in milliseconds
    }
    signal(SIGINT, SIG_DFL);
    raise(SIGINT);
}

// helper func
double time_diff(struct timeval x, struct timeval y) {
    double x_ms, y_ms, diff;

    x_ms = (double)x.tv_sec * 1000000 + (double)x.tv_usec;
    y_ms = (double)y.tv_sec * 1000000 + (double)y.tv_usec;

    diff = (double)x_ms - (double)y_ms;

    return diff;
}
